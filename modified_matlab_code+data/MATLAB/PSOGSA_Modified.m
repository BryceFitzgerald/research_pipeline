%PSOGSA source code v3.0, Generated by SeyedAli Mirjalili, 2011. 
%Adopted from: S. Mirjalili, S.Z. Mohd Hashim, �A New Hybrid PSOGSA 
%Algorithm for Function Optimization, in IEEE International Conference 
%on Computer and Information Application?ICCIA 2010), China, 2010, pp. 374-377.


                              %-------------------------------------------%
                              %         Evaluate the population           %           
                              %-------------------------------------------%                                 %--%
 %%% Variables %%%

%current_position:  Position of particles
%velocity:          Velocity
%force:             The gravitational force between the particles
%acceleration:      Acceleration
%mass:              Mass 
%dim:               Dimension of test functions
%n:                 Number of particles
%G0                 Gravitational constant
%low:               The lower bound of the search space
%up:                The higher bound of the search space

clc;
clear;

% Time in.
tic;

%********************************************************************************************************************
% Test Function Identification Numbers                                                                              *
%                                                                                                                   *
% 1  for ackley function                                                                                            *
% 2  for sphere function                                                                                            *
% 3  for permdb function                                                                                            *
% 4  for rotatedhyperellipsoid function                                                                             *
% 5  for griewank function                                                                                          *
% 6  for levy function optimal solution = (1, 1,..., 1))                                                            *
% 7  for rastrigin function                                                                                         *
% 8  for schwefel 26 function optimal solution = (420.9687, 420.9687,..., 420.9687))                                *
% 9  for sum of different powers function                                                                           *
% 10 for sum squares function                                                                                       *
% 11 for zakharov function                                                                                          *
% 12 for rosenbrock function optimal solution = (1, 1,..., 1)                                                       *
% 13 for powell function                                                                                            *
% 14 for three-hump camel function ***d = 2***                                                                      *
% 15 for easom function ***d = 2***                                                                                 *
% 16 for alpine 01 function                                                                                         *
% 17 for brown function pop: 5; avgfunctionevaluations: 210                                                         *
% 18 for exponential function                                                                                       *
% 19 for happy cat function optimal solution = (-1, -1,..., -1) TOUGH FUNCTION                                      *
% 20 for periodic function  TOUGH FUNCTION (also referred to as price 02 function)                                  *
% 21 for quartic function (random function)                                                                         *
% 22 for xin-she yang 01 function (random function)                                                                 *
% 23 for xin-she yang 03 function                                                                                   *
% 24 for step1 function (my function)                                                                               *
% 25 for chew function dimensions: 100,000                                                                          *
% 26 for holder table function ***d = 2***                                                                          *
% 27 for cross in tray function ***d = 2***                                                                         *
% 28 for schwefel 2.22 function                                                                                     *
% 29 for six-hump camel function ***d = 2***                                                                        *
% 30 for shubert 01 function Only 2D optimal solution = (-1.4251, -7.0835)is known, multiple D is UNKNOWN.          *
% 31 for cross leg table function ***d = 2***                                                                       *
% 32 for step2 function optimal solution = [-1.5, 0.5)                                                              *
% 33 for shekel's foxholes function ***d = 2***                                                                     *
% 34 for michalewicz function                                                                                       *
% 35 for schaffer function                                                                                          *
% 36 for himmelblau function ***d = 2***                                                                            *
% 37 for penalized 01 function optimal solution = (-1, -1,.., -1)                                                   *
% 38 for penalized 02 function optimal solution = (1, 1,.., 1)                                                      *
% 39 for perm0db function optimal solution = (1, 1/2, 1/3,..., 1/d)                                                 *
% 40 for drop wave function ***d = 2***                                                                             *
% 41 for leon function ***d = 2*** optimal solution = (1, 1)                                                        *
% 42 for langermann function ***d = 2*** optimal solution = (2.00299219, 1.006096)                                  *
% 43 for salomon function Tough Function: Even Initialized at 0 for each axis does not work.                        *
% 44 for egg holder function ***d = 2*** optimal solution = (512, 404.2319)                                         *
% 45 for damavandi function ***d = 2*** optimal solution = (2, 2)                                                   *
% 46 for sineenvelope function (also referred to as Schaffer function with dimension d = 2)                         *
% 47 for crowned cross function (the negative version of cross in tray function) ***d = 2***                        *
% 48 for trefethen function ***d = 2*** optimal solution = (-0.02440307923, 0.2106124261)                           *
% 49 for zero sum function optimal solution = sum(xi) = 0                                                           *
% 50 for stochastic function (also referred to as xin-she yang 07 function) optimal solution = (1/1, 1/2,..., 1/d)  *
% 51 for mishra 04 function ***d = 2*** optimal solution = (-9.941127263635860, -9.999571661999983)                 *
% 52 for mishra 03 function ***d = 2*** optimal solution = (-8.466613775046579, -9.998521308999999)                 *
% 53 for ripple 01 function ***d = 2*** optimal solution = (-1,-1)                                                  *
% 54 for bukin 06 function ***d = 2*** optimal solution = (-10,1)                                                   *
% 55 for branin 02 function ***d = 2*** optimal solution = (-3.196988423389338, 12.526257883092258)                 *
% 56 for tripod function ***d = 2*** optimal solution = (0, -50)                                                    *
% 57 for schwefel 06 function ***d = 2*** optimal solution = (1, 3)                                                 *
% 58 for schaffer 04 function ***d = 2*** optimal solution = (0, 1.253115)                                          *
% 59 for shubert 03 function optimal solution = multiple solutions SOMETHING AMISS ABOUT THIS FUNCTION              *
% 60 for xinsheyang 04 function                                                                                     *
% 61 for schaffer 02 function ***d = 2***                                                                           *
% 62 for chichinadze function ***d = 2*** optimal solution = (6.189866586965680, 0.5)                               *
% 63 for test tube holder function ***d = 2*** optimal solution = (-pi/2, 0)                                        *
% 64 for price 03 function (also referred to as modified rosenbrock function) ***d = 2*** optimal solution = (1, 1) *
% 65 for styblinski tang function optimal solution = (-2.903534018185960,..., -2.903534018185960)                   *
% 66 for weierstrass function                                                                                       *
%                                                                                                                   *
%                                                                                                                   *
%                                                                                                                   *
%                                                                                                                   *
%                                                                                                                   *
%                                                                                                                   *
%                                                                                                                   *
%                                                                                                                   *
%********************************************************************************************************************
%MODIFIED CODE:
% STEPS:
%  1. Create and read Log File
%  2. read input paramaters
%  3. Parse input and store to variables
%  4. execute program, write logs to file
%  5. print output to terminal
%  6. log exit status / metadata

%% STEP 1::: Create log file
dateString = datestr(now,0);
filename = compose("%s_%s.log",dateString,"_progamlogs");
fid = fopen(fullfile(tempdir, filename), 'a');

% if the file cannot be opened, force quit the program and return an error
if fid == -1
    error('CANNOT OPEN LOG FILE, ENDING RN');
    quit force;
end

% otherwise, log startup data

startupMessage_1 = '*******************************************************************';
startupMessage_2 = 'Modified PSOGSA Script. Version 0.1, LOGFILE BEGIN DATE: ';
fprintf(fid, '%s\n%s %s', startupMessage_1,startupMessage_2, dateString);

%% STEP 2: READ INPUT PARAMATERS
% write prompot and wait for input paramaters from user
% input will take the form of
% 'testFunctionIDNumber,NumberOfDimensions,NumberOfIterationsToFindAverage'

userStartupPrompt = "\nEnter Runtime Configuration:";
startupInput = input(userStartupPrompt, 's');

% Log user Input
fprintf(fid, '%s: %s', userStartupPrompt, startupInput);  


% parse and validate the input and crash if invalid
stringArray = split(startupInput, ',');

%if(size(stringArray) ~= size(rand(1,2,3)))
%    fprintf(fid, "Error, Input was unsucessfully read. CRASHING");
%    fclose(fid);
%    printf("Error, Input was unsucessfully read. CRASHING");
%    quit force;
%end

% otherwise, continue


    
%*****************************************************************************
% Input parameters.
TestFunctionIdentificationNumber = cellfun(@str2num,stringArray(1,1)); % <-- Enter the test function identification number here.
NumberOfDimensions = cellfun(@str2num,stringArray(2,1)); % <-- Enter the dimensions of the test function here.
NumberOfIterationsToFindTheAverage = cellfun(@str2num,stringArray(3,1));

% Control parameters.
if NumberOfDimensions <= 10
   SizeOfPopulation = 50; % <-- Enter the size of the population here.
   SizeOfExploiterPopulation = ceil(SizeOfPopulation / 2);%25
   MaximumNumberOfObjectiveFunctionEvaluationsAllowed = 100000;%10000000; % <-- Enter the maximum number of objective function evealuations allowed.
elseif NumberOfDimensions <= 30
   SizeOfPopulation = 75; % <-- Enter the size of the population here.
   SizeOfExploiterPopulation = ceil(SizeOfPopulation / 2);%40
   MaximumNumberOfObjectiveFunctionEvaluationsAllowed = 300000;%30000000; % <-- Enter the maximum number of objective function evealuations allowed.
elseif NumberOfDimensions <= 50
   SizeOfPopulation = 100;%75; % <-- Enter the size of the population here.
   SizeOfExploiterPopulation = ceil(SizeOfPopulation / 2);%40
   MaximumNumberOfObjectiveFunctionEvaluationsAllowed = 500000;%40000000; % <-- Enter the maximum number of objective function evealuations allowed.
elseif NumberOfDimensions <= 100
   SizeOfPopulation = 200;%100; % <-- Enter the size of the population here.
   SizeOfExploiterPopulation = ceil(SizeOfPopulation / 2);%50;
   MaximumNumberOfObjectiveFunctionEvaluationsAllowed = 1000000;%50000000; % <-- Enter the maximum number of objective function evealuations allowed.
elseif NumberOfDimensions <= 300
   SizeOfPopulation = 300;%125; % <-- Enter the size of the population here.
   SizeOfExploiterPopulation = ceil(SizeOfPopulation / 2);%65;
   MaximumNumberOfObjectiveFunctionEvaluationsAllowed = 5000000;%50000000; % <-- Enter the maximum number of objective function evealuations allowed.
elseif NumberOfDimensions <= 500
   SizeOfPopulation = 400;%125; % <-- Enter the size of the population here.
   SizeOfExploiterPopulation = ceil(SizeOfPopulation / 2);%65;
   MaximumNumberOfObjectiveFunctionEvaluationsAllowed = 10000000;%50000000; % <-- Enter the maximum number of objective function evealuations allowed.
else
   SizeOfPopulation = 500;%150; % <-- Enter the size of the population here.
   SizeOfExploiterPopulation = ceil(SizeOfPopulation / 2);%75;
   MaximumNumberOfObjectiveFunctionEvaluationsAllowed = 30000000;%50000000; % <-- Enter the maximum number of objective function evealuations allowed.
end
NumberOfIterations = 999999;
ObjectiveFunctionValueForThisSolution = NumberOfDimensions + 1;
SizeOfExplorerPopulation = SizeOfPopulation - SizeOfExploiterPopulation;
BeginExploiterPopulation = 1;
EndExploiterPopulation = SizeOfExploiterPopulation;
BeginExplorerPopulation = SizeOfExploiterPopulation + 1;
EndExplorerPopulation = SizeOfPopulation;
TestFunctions = {@ackley           @sphere          @permdb            @rotatedhyperellipsoid @griewank          @levy            @rastr           @schwef26       @sumpow       @sumsqu ...
                 @zakharov         @rosen           @powell            @camel3                @easom             @alpinen01fcn    @brownfcn        @exponentialfcn @happycatfcn  @periodicfcn ...
                 @quarticfcn       @xinsheyang01fcn @xinsheyang03fcn   @step1                 @chew              @holdertablefcn  @crossintrayfcn  @schwefel222fcn @camel6       @shubert01fcn ...
                 @crosslegtablefcn @step2           @shekelfoxholesfcn @michalewicz           @schaffer          @himmelblaufcn   @penalized01fcn  @penalized02fcn @perm0db      @drop ...
                 @leonfcn          @langer          @salomonfcn        @egg                   @damavandifcn      @sineenvelopefcn @crownedcrossfcn @trefethenfcn   @zerosumfcn   @stochasticfcn ...
                 @mishra04fcn      @mishra03fcn     @ripple01fcn       @bukin06fcn            @branin02fcn       @tripodfcn       @schwefel06fcn   @schaffer04fcn  @shubert03fcn @xinsheyang04fcn ...
                 @schaffer02fcn    @chichinadzefcn  @testtubeholderfcn @price03fcn            @styblinskitangfcn @weierstrassfcn};
BoundsOfTestFunctions = [-32.768  32.768; -5.12 5.12; -NumberOfDimensions NumberOfDimensions; -65.536 65.536; -600 600; -10 10; -5.12 5.12; -500 500; -1 1; -10 10;
                         -10 10; -5 10; -4 5; -5 5; -100 100; -10 10; -4 4; -1 1; -2 2; -10 10;
                         -1.28 1.28; -5 5; -20 20; -100 100; -10 10; -10 10; -15 15; -10 10; -5 5; -10 10;
                         -10 10; -NumberOfDimensions NumberOfDimensions; -65.536 65.536; 0 pi; -100 100; -6 6; -50 50; -50 50; -NumberOfDimensions NumberOfDimensions; -5.12 5.12;
                         0 10; 0 10; -100 100; -512 512; 0 14; -100 100; -10 10; -10 10; -10 10; -5 5;
                         -10 10; -10 10; -3 3; -15 3; -5 15; -100 100; -100 100; -100 100; -10 10; -10 10;
                         -100 100; -30 30; -10 10; -5 5; -5 5; -0.5 0.5];

% Problem Definition
n = SizeOfPopulation;
iteration = floor(MaximumNumberOfObjectiveFunctionEvaluationsAllowed / n);
low = BoundsOfTestFunctions(TestFunctionIdentificationNumber, 1);
up = BoundsOfTestFunctions(TestFunctionIdentificationNumber, 2);
dim = NumberOfDimensions;
benchmark_functions = TestFunctions{TestFunctionIdentificationNumber};

% Particle Swarm Optimization Gravitational Search Algorithm

SumOfSumsOfObjectiveFunctionEvaluations = 0;
NumberOfSuccesses = 0;
for jj = 1 : NumberOfIterationsToFindTheAverage
% Initialization for a new experimental run.
% Update the sum of objective function evaluations.
SumOfObjectiveFunctionEvaluations = 0;

% Start a new random number stream for a new experimental run.
rng('shuffle'); % The random number seed depends on the current time.

current_fitness =zeros(n,1);
gBest=zeros(1,dim);
gBestScore=inf;

for i=1:n
        pBestScore(i)=inf;
end
        pBest=zeros(n,dim);

G0=1;                                          % gravitational constant

Boundary_no = size(up',2);

if Boundary_no==1
    current_position = rand(n,dim).*(up-low)+low; %initial positions in the problem's boundary
end

% If each variable has a different up and low
if Boundary_no>1
    for i=1:dim
        up_i=up(i,1);
        low_i=low(i,1);
       current_position(:,i)=rand(n,1).*(up_i-low_i)+low_i; %initial positions in the problem's boundary
    end
end


velocity = .3*randn(n,dim) ;
acceleration=zeros(n,dim);
mass(n)=0;
force=zeros(n,dim);

C1=0.5; %C1 in Equation (9)
C2=1.5; %C2 in Equation (9)

%%main loop
iter = 0 ;                  % Iterations� counter
while  ( iter < iteration )

G=G0*exp(-23*iter/iteration); %Equation (4)
iter = iter + 1;
iter;
force=zeros(n,dim);
mass(n)=0;
acceleration=zeros(n,dim);

for i = 1:n
    fitness=0;
    %///Bound the search Space///
    %Tp=current_position(i,:)>up;Tm=current_position(i,:)<low;current_position(i,:)=(current_position(i,:).*(~(Tp+Tm)))+up.*Tp+low.*Tm;                     
    
    Flag4up=current_position(i,:)>up';
    Flag4low=current_position(i,:)<low';
    current_position(i,:)=(current_position(i,:).*(~(Flag4up+Flag4low)))+up'.*Flag4up+low'.*Flag4low; 
    %////////////////////////////
    
                                 %-------------------------------------------%
                                 %         Evaluate the population           %           
                                 %-------------------------------------------%      
    fitness=benchmark_functions(current_position(i,:));
    SumOfObjectiveFunctionEvaluations = SumOfObjectiveFunctionEvaluations + 1;
    current_fitness(i)=fitness;    
        
    if(pBestScore(i)>fitness)
        pBestScore(i)=fitness;
        pBest(i,:)=current_fitness(i,:);
    end
    if(gBestScore>fitness)
        gBestScore=fitness;
        gBest=current_position(i,:);
    end
    
end

    %disp(['Iteration ' num2str(i) ': Best Cost = ' num2str(valuess(i,1))]);

    fprintf(fid, (['\nSuccesses: ' num2str(NumberOfSuccesses) ', Run: ' num2str(jj) ', Iteration ' num2str(iter) ': Best Cost = '...
          num2str(gBestScore) ', Objective Function Evaluations = ' num2str(SumOfObjectiveFunctionEvaluations)]));
    
    % Check if the maximum number of objective function evaluations allowed is exceeded.
    if SumOfObjectiveFunctionEvaluations > MaximumNumberOfObjectiveFunctionEvaluationsAllowed
        break;
    end
    
    % Hallelujah
    if gBestScore < 1e-6
      SumOfSumsOfObjectiveFunctionEvaluations = SumOfSumsOfObjectiveFunctionEvaluations + SumOfObjectiveFunctionEvaluations;
      NumberOfSuccesses = NumberOfSuccesses + 1;
       
      %fprintf('\n***Hallelujah....Mission Accomplished!!!***\n');
      %    load handel
      %    sound(y,Fs)
       
      %fprintf('***The global best objective function value has so far been:  %3.6f.***\n\n\n', gBestScore);
      break;
    end

best=min(current_fitness);
worst=max(current_fitness);

        GlobalBestCost(iter)=gBestScore;
        GlobalBestCost(iter);
        best;

    for pp=1:n
        if current_fitness(pp)==best
            break;
        end
        
    end
    
    bestIndex=pp;
            
    for pp=1:dim
        best_fit_position(iter,1)=best;
        best_fit_position(iter,pp+1)=current_position(bestIndex,pp);   
    end


                                               %-------------------%
                                               %   Calculate Mass  %
                                               %-------------------%
    for i=1:n
    mass(i)=(current_fitness(i)-0.99*worst)/(best-worst);    
    end

for i=1:n
    mass(i)=mass(i)*5/sum(mass);    
    
end

                                               %-------------------%
                                               %  Force    update  %
                                               %-------------------%

for i=1:n
    for j=1:dim
        for k=1:n
            if(current_position(k,j)~=current_position(i,j))
                % Equation (3)
                force(i,j)=force(i,j)+ rand()*G*mass(k)*mass(i)*(current_position(k,j)-current_position(i,j))/abs(current_position(k,j)-current_position(i,j));
                
            end
        end
    end
end
                                               %------------------------------------%
                                               %  Accelations $ Velocities  UPDATE  %
                                               %------------------------------------%

for i=1:n
       for j=1:dim
            if(mass(i)~=0)
                %Equation (6)
                acceleration(i,j)=force(i,j)/mass(i);
            end
       end
end   

for i=1:n
        for j=1:dim
            %Equation(9)
            velocity(i,j)=rand()*velocity(i,j)+C1*rand()*acceleration(i,j) + C2*rand()*(gBest(j)-current_position(i,j));
        end
end
                                               %--------------------------%
                                               %   positions   UPDATE     %
                                               %--------------------------%
                                                        
%Equation (10) 
current_position = current_position + velocity ;
 
end

end % End Experimental Runs

%fprintf('\n***The probablity of success is: %2.4f.***\n\n', NumberOfSuccesses / NumberOfIterationsToFindTheAverage);
%fprintf('***The average number of objective function evaluations is: %3.6f.***\n\n', ceil(SumOfSumsOfObjectiveFunctionEvaluations / NumberOfSuccesses));

% Compute and print the elapsed time.
TimeIntervalBetweenBeginTimeAndNow = toc;
InSeconds = mod(TimeIntervalBetweenBeginTimeAndNow, 60);
TimeIntervalBetweenBeginTimeAndNow = (TimeIntervalBetweenBeginTimeAndNow - InSeconds) / 60;
InSeconds = floor(InSeconds);
InMinutes = mod(TimeIntervalBetweenBeginTimeAndNow, 60);
InHours = (TimeIntervalBetweenBeginTimeAndNow - InMinutes) / 60;
%fprintf('Elapsed time is %2i Hours %2i Minutes %2i Seconds.\n\n', InHours, InMinutes, InSeconds);

fprintf(fid, "\n%3.6f,%2.4f,%3.6f,%2i,%2i,%2i", gBestScore, NumberOfSuccesses / NumberOfIterationsToFindTheAverage, ceil(SumOfSumsOfObjectiveFunctionEvaluations / NumberOfSuccesses), InHours, InMinutes,InSeconds);
disp( compose("%3.6f,%2.4f,%3.6f,%2i,%2i,%2i", gBestScore, NumberOfSuccesses / NumberOfIterationsToFindTheAverage, ceil(SumOfSumsOfObjectiveFunctionEvaluations / NumberOfSuccesses), InHours, InMinutes, InSeconds));